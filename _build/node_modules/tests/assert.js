// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."
"use strict";

// ****
// An assertion library that works the way *I* want it to. <oldmanvoice>Get off my lawn!</oldmanvoice>
// ****

const chai = require("./vendor/chai-4.1.2.js").assert;
const util = require("node:util");
const type = require("util/type");

exports.fail = function(message, actual, expected) {
	chai.fail(actual, expected, message);
};

exports.todo = function(message) {
	message = message ? `: ${message}` : "";
	exports.fail(`TO DO${message}`);
};

exports.defined = function(actual, message) {
	message = message ? `${message}: ` : "";
	if (actual === undefined) exports.fail(message + "expected value, but was undefined");
};

exports.isUndefined = function(actual, message) {
	chai.isUndefined(actual, message);
};

exports.isTrue = function(actual, message) {
	chai.isTrue(actual, message);
};

exports.isFalse = function(actual, message) {
	chai.isFalse(actual, message);
};

exports.isNull = function(actual, message) {
	chai.isNull(actual, message);
};

exports.isNotNull = function(actual, message) {
	chai.isNotNull(actual, message);
};

exports.atLeast = function(actual, expected, message) {
	chai.isAtLeast(actual, expected, message);
};

exports.atMost = function(actual, expected, message) {
	chai.isAtMost(actual, expected, message);
};

exports.equal = function(actual, expected, message) {
	checkExpected(expected);
	if (expected !== actual) {
		fail(message, "expected equality", actual, expected);
	}
};

exports.notEqual = function(actual, expected, message) {
	checkExpected(expected);
	chai.notStrictEqual(actual, expected, message);
};

exports.deepEqual = function(actual, expected, message) {
	checkExpected(expected);
	if (!util.isDeepStrictEqual(actual, expected)) {
		fail(message, "expected deep equality", actual, expected);
	}
};

exports.type = function(actual, expected, message) {
	checkExpected(expected);
	const error = type.check(actual, expected);
	if (error !== null) {
		fail(message, "type should match", actual, type.describe(expected));
	}
};

exports.objEqual = function(actual, expected, message) {
	checkExpected(expected);

	message = message ? `${message}: ` : "";
	exports.defined(actual, message);
	if (expected.equals === undefined) exports.fail(message + "'expected' does not have equals() method");
	if (!expected.equals(actual)) fail(message, "should be equal()", actual, expected);
};

exports.objNotEqual = function(actual, expected, message) {
	checkExpected(expected);

	message = message ? `${message}: ` : "";
	exports.defined(actual, message);
	if (actual.equals === undefined) exports.fail(message + "does not have equals() method");
	exports.isFalse(actual.equals(expected), message + "expected '" + expected + "' and '" + actual + "' to be not be equal(), but they were");
};

exports.between = function(value, min, max, message) {
	exports.defined(value, message);
	message = message ? `${message}: ` : "";
	if (value < min || value > max) {
		exports.fail(message + "expected value between " + min + " and " + max + " (inclusive), but was " + value);
	}
};

exports.match = function(actual, expectedRegex, message) {
	if (!expectedRegex.test(actual)) fail(message, "should match regex", actual, expectedRegex);
};

exports.matchesGroup = function(actual, regex, expectedMatch, message) {
	message = message ?? "regex group";
	const regexResult = regex.exec(actual);
	const actualMatch = regexResult === null ? null : regexResult[1];

	if (expectedMatch === null && actualMatch === null) {
		return;
	}
	else if (expectedMatch === null && actualMatch !== null) {
		exports.fail(`should not have found ${message}, but it was '${actualMatch}' (searched with ${regex})`);
	}
	else if (expectedMatch !== null && actualMatch === null) {
		exports.fail(`${message} expected '${expectedMatch}', but nothing was found (searched with ${regex})`);
	}
	else {
		exports.equal(regexResult[1], expectedMatch, message);
	}
};

exports.includes = function(actual, expected, message) {
	checkExpected(expected);
	if (!actual.includes(expected)) {
		fail(message, "actual value should include expected value", actual, expected);
	}
};

exports.notIncludes = function(actual, expected, message) {
	checkExpected(expected);
	if (actual.includes(expected)) {
		fail(message, "actual value should not include expected value", actual, expected);
	}
};

exports.noException = function(fn) {
	fn();
};

exports.exception = function(fn, expectedRegexOrExactString, message) {
	try {
		fn();
	}
	catch (err) {
		if (expectedRegexOrExactString === undefined) return;
		if (typeof expectedRegexOrExactString === "string") {
			exports.equal(err.message, expectedRegexOrExactString, message);
		}
		else {
			exports.match(err.message, expectedRegexOrExactString, message);
		}
		return;
	}
	fail(message, "Expected exception");
};

exports.exceptionAsync = async function(fnAsync, expectedRegexOrExactString, message) {
	try {
		await fnAsync();
	}
	catch (err) {
		if (expectedRegexOrExactString === undefined) return;
		if (typeof expectedRegexOrExactString === "string") {
			exports.equal(err.message, expectedRegexOrExactString, message);
		}
		else {
			exports.match(err.message, expectedRegexOrExactString, message);
		}
		return;
	}
	fail(message, "Expected exception");
};

exports.noExceptionAsync = async function(fnAsync) {
	await fnAsync();
};

function checkExpected(expected) {
	if (expected === undefined) exports.fail("'undefined' provided as expected value in assertion");
}

function fail(userMessage, assertionMessage, actual, expected) {
	userMessage = userMessage ? `${userMessage}: ` : "";
	exports.fail(`${userMessage}${assertionMessage}`, actual, expected);
}