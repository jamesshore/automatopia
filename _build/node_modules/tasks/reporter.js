// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."

import * as ensure from "util/ensure.js";
import ConsoleOutput from "infrastructure/console_output.js";
import Clock from "infrastructure/clock.js";
import OutputTracker from "infrastructure/low_level/output_tracker.js";
import Colors from "infrastructure/colors.js";
import EventEmitter from "node:events";

const DEFAULT_PROGRESS_TEXT = ".";
const DEFAULT_FAILURE_TEXT = Colors.brightRed.inverse("X");

const USAGE_EVENT = "usage";

const ACTION = {
	START: "start",
	PROGRESS: "progress",
	DEBUG: "debug",
	FAILURE: "failure",
	FOOTER: "footer",
	END: "end",
};

/**
 * Writes build progress as a headline, a series of dots, and an elapsed time.
 */
export default class Reporter {

	/**
	 * An enum for {@link Reporter#track}.
	 * @returns {{STARTED: string, PROGRESS: string, FOOTER: string, END: string}}
	 */
	static get ACTION() {
		return ACTION;
	}

	/**
	 * Used for runtime type checking.
	 * @returns {Report} The Reporter.Report class.
	 */
	static get Report() {
		return Report;
	}

	/**
	 * Factory method. Creates the reporter.
	 * @param {boolean} [debug=false] Whether to write debug logs. Defaults to false.
	 * @param {ConsoleOutput} [stdout] Where to write the output. Defaults to stdout.
	 * @returns {Reporter} The reporter.
	 */
	static create({
		debug = false,
		stdout = ConsoleOutput.createStdout(),
	} = {}) {
		ensure.signature(arguments, [[ undefined, {
			debug: [ undefined, Boolean ],
			stdout: [ undefined, ConsoleOutput ],
		}]]);

		return new this(stdout, Clock.create(), debug);
	}

	/**
	 * Factory method. Creates a 'nulled' reporter that discards its output.
	 * @param {ConsoleOutput} [stdout] Where to write the output. Defaults to discarding the output.
	 * @param {Clock} [clock] The system clock. Defaults to a 'nulled' clock that doesn't advance.
	 * @returns {Reporter} The reporter.
	 */
	static createNull({
		stdout = ConsoleOutput.createNull(),
		clock = Clock.createNull(),
	} = {}) {
		ensure.signature(arguments, [[ undefined, {
			stdout: [ undefined, ConsoleOutput ],
			clock: [ undefined, Clock ],
		}]]);

		return new this(stdout, clock);
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(stdout, clock, debug) {
		this._stdout = stdout;
		this._clock = clock;
		this._debug = debug;
		this._emitter = new EventEmitter();
	}

	/**
	 * Start a new report by writing a headline and then running a function. When the function ends, a dot will be written (if the function didn't call {@link Report#progress}) along with the elapsed time.
	 * @template T
	 * @param {string} headline The headline to write.
	 * @param {(report: Report) => Promise<T>} fnAsync The function to call. Use the `report` parameter to write to the report.
	 * @returns {Promise<T>} The value returned by `fnAsync`.
	 */
	async startAsync(headline, fnAsync) {
		ensure.signature(arguments, [ String, Function ]);

		const report = new Report(this._stdout, this._clock, this._debug, this._emitter, headline, false);
		return await runReportBodyAsync(report, fnAsync);
	}

	/**
	 * Start a 'quiet' report. It's just like {@link Report#startAsync}, except that it only writes the headline and elapsed time if the function writes something to the report.
	 * template T
	 * @param {string} headline The headline to write.
	 * @param {(report: Report) => Promise<T>} fnAsync The function to call. Use the `report` parameter to write to the report.
	 * @returns {Promise<T>} The value returned by `fnAsync`.
	 */
	async quietStartAsync(headline, fnAsync) {
		ensure.signature(arguments, [ String, Function ]);

		const report = new Report(this._stdout, this._clock, this._debug, this._emitter, headline, true);
		return await runReportBodyAsync(report, fnAsync);
	}

	/**
	 * Track what this reporter outputs. Each action is tracked by its headline, an action, and associated data.
	 * @returns {OutputTracker} The tracker.
	 * @see Reporter.ACTION
	 */
	track() {
		return new OutputTracker(this._emitter, USAGE_EVENT);
	}

}

async function runReportBodyAsync(report, bodyFnAsync) {
	try {
		return await bodyFnAsync(report);
	}
	catch (err) {
		report.started();
		throw err;
	}
	finally {
		endReport(report);
	}
}

function endReport(report) {
	if (report._isQuiet && !report._started && report._footer === "") return;

	if (!report._wroteProgress) report._writeProgress();

	const elapsedSec = report.elapsedMs / 1000;
	report._stdout.write(Colors.brightWhite.dim(` (${elapsedSec.toFixed(2)}s)\n`));

	report._stdout.write(report._footer);
	report._ended = true;
	report._emitter.emit(USAGE_EVENT, { report: report._headline, action: ACTION.END });
}


/**
 * An individual report. A report consists of a headline, a series of dots, the elapsed time (which is added automatically), and optional footers.
 */
class Report {

	/**
	 * Use {@link Reporter}'s factory methods instead.
	 */
	constructor(stdout, clock, debug, emitter, headline, isQuiet) {
		this._stdout = stdout;
		this._clock = clock;
		this._debug = debug;
		this._headline = headline;
		this._isQuiet = isQuiet;
		this._emitter = emitter;

		this._started = false;
		this._startTime = this._clock.now();
		this._wroteProgress = false;
		this._footer = "";
		this._ended = false;

		if (!this._isQuiet) this.started();
	}

	/**
	 * @returns {number} The amount of time, in milliseconds, since the report began.
	 */
	get elapsedMs() {
		return this._clock.millisecondsSince(this._startTime);
	}

	/**
	 * Write the report headline, if it hasn't already been written.
	 * @see Reporter.quietStartAsync
	 */
	started() {
		ensure.signature(arguments, []);

		if (!this._started) {
			this._stdout.write(`${this._headline}: `);
			this._started = true;
			this._emitter.emit(USAGE_EVENT, { report: this._headline, action: ACTION.START });
		}
	}

	/**
	 * Write a dot (or other text), indicating that work is progressing.
	 * @param {string} [text="."] The text to write.
	 * @param {string} [debug] Text to record in the output tracker.
	 */
	progress(text) {
		ensure.signature(arguments, [[ undefined, String ]]);

		this._writeProgress(text);

		const textEvent = text === undefined ? {} : { text };
		this._emitter.emit(USAGE_EVENT, { report: this._headline, action: ACTION.PROGRESS, ...textEvent });
	}

	/**
	 * Write text if the reporter is in debug mode; otherwise, write nothing.
	 * @param {string} text The text to write
	 */
	debug(text) {
		ensure.signature(arguments, [ String ]);

		this.#writeDebug(text);
		if (this._debug) this._emitter.emit(USAGE_EVENT, { report: this._headline, action: ACTION.DEBUG, text });
	}

	/**
	 * Write a red X (or other text) along with an optional footer, indicating that something failed.
	 * @param {string} [footer] The footer to write, if any.
	 * @param {string} [progress="X"] The progress text to write. Defaults to a red "X".
	 * @param {string} [debug] Text to record in the output tracker.
	 */
	failure(footer = "", {
		progress,
		debug,
	} = {}) {
		ensure.signature(arguments, [[ undefined, String ], [ undefined, {
			progress: [ undefined, String ],
			debug: [ undefined, String ],
		}]]);

		this.#writeFooter(footer);
		this._writeProgress(progress ?? DEFAULT_FAILURE_TEXT);
		this.#writeDebug(debug);

		const footerEvent = footer === "" ? {} : { footer };
		const progressEvent = progress === undefined ? {} : { progress };
		const debugEvent = debug === undefined ? {} : { debug };
		this._emitter.emit(USAGE_EVENT, {
			report: this._headline,
			action: ACTION.FAILURE,
			...footerEvent,
			...progressEvent,
			...debugEvent,
		});
	}

	/**
	 * Additional text to write after the function ends. Useful for errors and summary information.
	 * @param {string} text The text to write.
	 */
	footer(text) {
		ensure.signature(arguments, [ String ]);
		if (text === "") return;

		this.#writeFooter(text);
		this._emitter.emit(USAGE_EVENT, { report: this._headline, action: ACTION.FOOTER, text });
	}

	_writeProgress(text = DEFAULT_PROGRESS_TEXT) {
		this.started();
		this._stdout.write(text);
		this._wroteProgress = true;
	}

	#writeDebug(text) {
		if (this._debug && text !== undefined) {
			this.started();
			this._stdout.write(text);
		}
	}

	#writeFooter(text) {
		this._footer += text;
	}
}
