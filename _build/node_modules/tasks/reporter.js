// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."

import * as ensure from "util/ensure.js";
import ConsoleOutput from "infrastructure/console_output.js";
import Clock from "infrastructure/clock.js";
import OutputTracker from "infrastructure/low_level/output_tracker.js";
import Colors from "infrastructure/colors.js";
import EventEmitter from "node:events";

const DEFAULT_PROGRESS_TEXT = ".";
const DEFAULT_FAILURE_TEXT = Colors.brightRed.inverse("X");

const USAGE_EVENT = "usage";

const ACTION = {
	STARTED: "started",
	PROGRESS: "progress",
	FOOTER: "footer",
	END: "end",
};

/**
 * Writes build progress as a headline, a series of dots, and an elapsed time.
 */
export default class Reporter {

	/**
	 * An enum for {@link Reporter#trackUsage}.
	 * @returns {{STARTED: string, PROGRESS: string, FOOTER: string, END: string}}
	 */
	static get ACTION() {
		return ACTION;
	}

	/**
	 * Used for runtime type checking.
	 * @returns {Report} The Reporter.Report class.
	 */
	static get Report() {
		return Report;
	}

	/**
	 * Factory method. Creates the reporter.
	 * @param {ConsoleOutput} [stdout] Where to write the output. Defaults to stdout.
	 * @returns {Reporter} The reporter.
	 */
	static create(stdout = ConsoleOutput.createStdout()) {
		return new this(stdout, Clock.create());
	}

	/**
	 * Factory method. Creates a 'nulled' reporter that discards its output.
	 * @param {ConsoleOutput} [stdout] Where to write the output. Defaults to discarding the output.
	 * @param {Clock} [clock] The system clock. Defaults to a 'nulled' clock that doesn't advance.
	 * @returns {Reporter} The reporter.
	 */
	static createNull({
		stdout = ConsoleOutput.createNull(),
		clock = Clock.createNull(),
	} = {}) {
		ensure.signature(arguments, [[ undefined, {
			stdout: [ undefined, ConsoleOutput ],
			clock: [ undefined, Clock ],
		}]]);

		return new this(stdout, clock);
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(stdout, clock) {
		this._stdout = stdout;
		this._clock = clock;
		this._emitter = new EventEmitter();
	}

	/**
	 * Start a new report by writing a headline and then running a function. When the function ends, a dot will be written (if the function didn't call {@link Report#progress}) along with the elapsed time.
	 * @template T
	 * @param {string} headline The headline to write.
	 * @param {(report: Report) => Promise<T>} fnAsync The function to call. Use the `report` parameter to write to the report.
	 * @returns {Promise<T>} The value returned by `fnAsync`.
	 */
	async startAsync(headline, fnAsync) {
		ensure.signature(arguments, [ String, Function ]);

		const report = new Report(this._stdout, this._clock, this._emitter, headline, false);
		return await runReportBodyAsync(report, fnAsync);
	}

	/**
	 * Start a 'quiet' report. It's just like {@link Report#startAsync}, except that it only writes the headline and elapsed time if the function writes something to the report.
	 * template T
	 * @param {string} headline The headline to write.
	 * @param {(report: Report) => Promise<T>} fnAsync The function to call. Use the `report` parameter to write to the report.
	 * @returns {Promise<T>} The value returned by `fnAsync`.
	 */
	async quietStartAsync(headline, fnAsync) {
		ensure.signature(arguments, [ String, Function ]);

		const report = new Report(this._stdout, this._clock, this._emitter, headline, true);
		return await runReportBodyAsync(report, fnAsync);
	}

	/**
	 * Track what this reporter outputs. Each action is tracked by its headline, an action, and associated data.
	 * @returns {OutputTracker} The tracker.
	 * @see Reporter.ACTION
	 */
	trackUsage() {
		return new OutputTracker(this._emitter, USAGE_EVENT);
	}

}

async function runReportBodyAsync(report, bodyFnAsync) {
	try {
		return await bodyFnAsync(report);
	}
	catch (err) {
		report.started();
		throw err;
	}
	finally {
		endReport(report);
	}
}

function endReport(report) {
	if (report._isQuiet && !report._started && report._footer === "") return;

	if (!report._wroteProgress) writeProgress(report, DEFAULT_PROGRESS_TEXT);

	const elapsedSec = report.elapsedMs / 1000;
	report._stdout.write(Colors.brightWhite.dim(` (${elapsedSec.toFixed(2)}s)\n`));

	report._stdout.write(report._footer);
	report._ended = true;
	report._emitter.emit(USAGE_EVENT, { [report._headline]: { action: ACTION.END }});
}


/**
 * An individual report. A report consists of a headline, a series of dots, the elapsed time (which is added automatically), and optional footers.
 */
class Report {

	/**
	 * Use {@link Reporter}'s factory methods instead.
	 */
	constructor(stdout, clock, emitter, headline, isQuiet) {
		this._stdout = stdout;
		this._clock = clock;
		this._headline = headline;
		this._isQuiet = isQuiet;
		this._emitter = emitter;

		this._started = false;
		this._startTime = this._clock.now();
		this._wroteProgress = false;
		this._footer = "";
		this._ended = false;

		if (!this._isQuiet) this.started();
	}

	/**
	 * @returns {number} The amount of time, in milliseconds, since the report began.
	 */
	get elapsedMs() {
		return this._clock.millisecondsSince(this._startTime);
	}

	/**
	 * Write the report headline, if it hasn't already been written.
	 * @see Reporter.quietStartAsync
	 */
	started() {
		ensure.signature(arguments, []);

		if (!this._started) {
			this._stdout.write(`${this._headline}: `);
			this._started = true;
			this._emitter.emit(USAGE_EVENT, { [this._headline]: { action: ACTION.STARTED } });
		}
	}

	/**
	 * Write a dot (or other text), indicating that work is progressing.
	 * @param {string} [text="."] The text to write.
	 * @param {string} [debug] Text to record in the output tracker.
	 */
	progress({
		text = DEFAULT_PROGRESS_TEXT,
		debug = "",
	} = {}) {
		ensure.signature(arguments, [[ undefined, {
			text: [ undefined, String ],
			debug: [ undefined, String ],
		}]]);

		writeProgress(this, text);
		this._emitter.emit(USAGE_EVENT, { [this._headline]: { action: ACTION.PROGRESS, debug } });
	}

	/**
	 * Write a red X (or other text) along with an optional footer, indicating that something failed.
	 * @param {string} [footer] The footer to write, if any.
	 * @param {string} [text="X"] The text to write. Defaults to a red "X".
	 * @param {string} [debug] Text to record in the output tracker.
	 */
	failure(footer = "", {
		text = DEFAULT_FAILURE_TEXT,
		debug = "",
	} = {}) {
		ensure.signature(arguments, [[ undefined, String ], [ undefined, {
			text: [ undefined, String ],
			debug: [ undefined, String ],
		}]]);

		this.progress({ text, debug });
		this.footer(footer);
	}

	/**
	 * Additional text to write after the function ends. Useful for errors and summary information.
	 * @param {string} text The text to write.
	 */
	footer(text) {
		ensure.signature(arguments, [ String ]);
		if (text === "") return;

		this._footer += text;
		this._emitter.emit(USAGE_EVENT, { [this._headline]: { action: ACTION.FOOTER, text }});
	}
}

function writeProgress(self, text) {
	self.started();
	self._stdout.write(text);
	self._wroteProgress = true;
}