// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."
import { assert, test } from "tests";
import * as ensure from "util/ensure.js";
import Reporter from "tasks/reporter.js";
import ConsoleOutput from "infrastructure/console_output.js";
import Clock from "infrastructure/clock.js";
import Colors from "infrastructure/colors.js";

const IRRELEVANT_TEXT = "irrelevant_text";
const TIME = Colors.brightWhite.dim(" (0.00s)\n");
const FAILURE = Colors.brightRed.inverse("X");

export default test(({ describe }) => {

	describe("reports", ({ it }) => {

		it("writes headline, progress, and footer", async () => {
			const { reporter, stdout } = create();

			await reporter.startAsync("my headline", (report) => {
				report.progress();
				report.progress();
				report.progress();
				report.footer("footer 1");
				report.footer("footer 2");
			});

			assertStdoutEqual(stdout, `my headline: ...${TIME}footer 1footer 2`);
		});

		it("returns result of report function", async () => {
			const { reporter } = create();

			const result1 = await reporter.startAsync(IRRELEVANT_TEXT, () => {
				return 1234;
			});
			assert.equal(result1, 1234);

			const result2 = await reporter.quietStartAsync(IRRELEVANT_TEXT, () => {
				return 5678;
			});
			assert.equal(result2, 5678);
		});

		it("writes failures as a convenience function", async () => {
			const { reporter, stdout } = create();

			await reporter.startAsync("my headline", report => {
				report.failure();
				report.failure("my_footer\n");
				report.failure("another_footer", { progress: "my text" });
			});

			assertStdoutEqual(stdout, `my headline: ${FAILURE}${FAILURE}my text${TIME}my_footer\nanother_footer`);
		});

		it("always writes at least one progress dot", async () => {
			const { reporter, stdout } = create();

			await reporter.startAsync("my headline", () => {});

			assertStdoutEqual(stdout, `my headline: .${TIME}`);
		});

		it("writes progress dot and footer even when exception is thrown", async () => {
			const { reporter, stdout } = create();

			await assert.errorAsync(
				() => reporter.startAsync("my headline", (report) => {
					report.footer("my footer");
					throw new Error("my error");
				}),
				"my error",
				"should throw exception"
			);

			assertStdoutEqual(stdout, `my headline: .${TIME}my footer`, "should write dot and footer");
		});

		it("allows progress text to be specified", async () => {
			const { reporter, stdout } = create();

			await reporter.startAsync("my headline", report => {
				report.progress("X");
			});

			assertStdoutEqual(stdout, `my headline: X${TIME}`);
		});

		it("provides elapsed time", async () => {
			const { reporter, clock } = create();

			await reporter.startAsync(IRRELEVANT_TEXT, async (report) => {
				await clock.tickAsync(1234);
				assert.equal(report.elapsedMs, 1234);
			});
		});

		it("writes elapsed time", async () => {
			const { reporter, stdout, clock } = create();

			await reporter.startAsync("my headline", async (report) => {
				report.progress();
				await clock.tickAsync(1234);
			});

			assertStdoutEqual(stdout, `my headline: .${Colors.brightWhite.dim(" (1.23s)\n")}`);
		});

		it("always writes footer last", async () => {
			const { reporter, stdout } = create();

			await reporter.startAsync("my headline", (report) => {
				report.footer("footer");
				report.progress();
			});

			assertStdoutEqual(stdout, `my headline: .${TIME}footer`);
		});

	});


	describe("quiet reports", ({ it }) => {

		it("doesn't write quiet reports' headline until they explicitly say been started", async () => {
			const { reporter, stdout } = create();

			await reporter.quietStartAsync("my headline", (report) => {
				assertStdoutEqual(stdout, "");
				report.started();
				assertStdoutEqual(stdout, "my headline: ");
			});
		});

		it("quiet reports consider progress to be equivalent to starting", async () => {
			const { reporter, stdout } = create();

			await reporter.quietStartAsync("my headline", (report) => {
				assertStdoutEqual(stdout, "");

				report.progress();
				assertStdoutEqual(stdout, "my headline: .");
			});
		});

		it("doesn't write quiet headlines at all if the report isn't started and there's no footer", async () => {
			const { reporter, stdout } = create();

			await reporter.quietStartAsync("my headline", () => {});
			assertStdoutEqual(stdout, "");
		});

		it("does write quiet headlines if there's a footer, even if there's no progress", async () => {
			const { reporter, stdout } = create();

			await reporter.quietStartAsync("my headline", (report) => {
				report.footer("footer");
			});

			assertStdoutEqual(stdout, `my headline: .${TIME}footer`);
		});

		it("does write quiet headlines if there's an exception, even if there's no progress or footer", async () => {
			const { reporter, stdout } = create();

			await assert.errorAsync(
				() => reporter.quietStartAsync("my headline", (report) => {
					throw new Error("my error");
				}),
				"my error",
			);

			assertStdoutEqual(stdout, `my headline: .${TIME}`);
		});

	});


	describe("debug mode", ({ it }) => {

		it("by default, debug messages are invisible", async () => {
			const { reporter, stdout } = create({ debug: false });

			await reporter.startAsync("my headline", (report) => {
				report.progress("P");
				report.debug("my debug message");
			});

			assertStdoutEqual(stdout, `my headline: P${TIME}`);
		});

		it("invisible debug messages don't cause quiet headlines to be written", async () => {
			const { reporter, stdout } = create({ debug: false });

			await reporter.quietStartAsync("my headline", (report) => {
				report.debug("my debug message");
			});

			assertStdoutEqual(stdout, "");
		});

		it("displays debug messages when reporter is in debug mode", async () => {
			const { reporter, stdout } = create({ debug: true });

			await reporter.startAsync("my headline", (report) => {
				report.progress("P");
				report.debug("my debug message");
			});

			assertStdoutEqual(stdout, `my headline: Pmy debug message${TIME}`);
		});

		it("causes quiet headlines to be written when reporter is in debug mode", async () => {
			const { reporter, stdout } = create({ debug: true });

			await reporter.quietStartAsync("my headline", (report) => {
				report.debug("my debug message");
			});

			assertStdoutEqual(stdout, `my headline: my debug message.${TIME}`);
		});

	});


	describe("tracking", ({ it }) => {

		it("tracks reports starting and ending, but doesn't track default dot", async () => {
			const { reporter, reportTracker } = create();

			await reporter.startAsync("report1", async (report1) => {
			});
			assert.equal(reportTracker.data, [
				{ report: "report1", action: "start" },
				{ report: "report1", action: "end" },
			]);
		});

		it("doesn't track quiet reports until they actually start", async () => {
			const { reporter, reportTracker } = create();

			await reporter.quietStartAsync("report1", (report1) => {
				assert.equal(reportTracker.data, []);

				report1.started();
				assert.equal(reportTracker.data, [
					{ report: "report1", action: "start" },
				]);
			});
		});

		it("tracks progress", async () => {
			const { reporter, reportTracker } = create();

			await reporter.startAsync("report1", (report1) => {
				reportTracker.consume();

				report1.progress();
				report1.progress("my text");

				assert.equal(reportTracker.data, [
					{ report: "report1", action: "progress" },
					{ report: "report1", action: "progress", text: "my text" },
				]);
			});
		});

		it("tracks debug when debug mode is on", async () => {
			const { reporter, reportTracker } = create({ debug: true });

			await reporter.startAsync("report1", (report1) => {
				reportTracker.consume();

				report1.debug("my debug");

				assert.equal(reportTracker.data, [
					{ report: "report1", action: "debug", text: "my debug" },
				]);
			});
		});

		it("doesn't track debug when debug mode is off", async () => {
			const { reporter, reportTracker } = create({ debug: false });

			await reporter.startAsync("report1", (report1) => {
				reportTracker.consume();

				report1.debug("my debug");

				assert.equal(reportTracker.data, []);
			});
		});

		it("tracks failures", async () => {
			const { reporter, reportTracker } = create();

			await reporter.startAsync("report1", (report1) => {
				reportTracker.consume();

				report1.failure();
				report1.failure("footer 1");
				report1.failure("footer 2", { progress: "progress 1" });
				report1.failure("footer 3", { debug: "debug 1" });
				report1.failure("footer 4", { progress: "progress 2", debug: "debug 2" });

				assert.equal(reportTracker.data, [
					{ report: "report1", action: "failure" },
					{ report: "report1", action: "failure", footer: "footer 1" },
					{ report: "report1", action: "failure", footer: "footer 2", progress: "progress 1" },
					{ report: "report1", action: "failure", footer: "footer 3", debug: "debug 1" },
					{ report: "report1", action: "failure", footer: "footer 4", progress: "progress 2", debug: "debug 2" },
				]);
			});
		});

		it("tracks footers in the order they were created, not at the end as they are written", async () => {
			const { reporter, reportTracker } = create();

			await reporter.startAsync("report1", (report1) => {
				reportTracker.consume();

				report1.progress("before");
				report1.footer("my footer");
				report1.progress("after");

				assert.equal(reportTracker.data, [
					{ report: "report1", action: "progress", text: "before" },
					{ report: "report1", action: "footer", text: "my footer" },
					{ report: "report1", action: "progress", text: "after" },
				]);
			});

		});

	});

});

function create({
	debug = false,
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		debug: Boolean,
	}]]);

	const clock = Clock.createNull();
	const stdout = ConsoleOutput.createNull();
	const stdoutTracker = stdout.track();

	const reporter = new Reporter(stdout, clock, debug);
	const reportTracker = reporter.track();

	return {
		reporter,
		reportTracker,
		stdout: stdoutTracker.data,
		clock,
	};
}

function assertStdoutEqual(stdout, expected, message) {
	assert.equal(stdout.join(""), expected, message);
}