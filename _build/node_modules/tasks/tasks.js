// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."
import * as ensure from "util/ensure.js";
import Clock from "infrastructure/clock.js";
import OutputTracker from "infrastructure/low_level/output_tracker.js";
import FileSystem from "infrastructure/file_system.js";
import EventEmitter from "node:events";

const TASK_EVENT = "task";
const ACTION = {
	START: "start",
	END: "end",
};

/**
 * A set of tasks. Each task consists of a name and an associated function. The tasks can be run programmatically or
 * from the command-line.
 */
export default class Tasks extends EventEmitter {

	/**
	 * Task tracking event.
	 */
	static get TASK_EVENT() {
		return TASK_EVENT;
	}

	/**
	 * An enum for {@link Tasks#track} and the event emitter.
	 * @returns {{START: string, END: string}}
	 */
	static get ACTION() {
		return ACTION;
	}

	/**
	 * Factory method.
	 * @param {string} incrementalDir Path to a directory to use for incremental tasks (see
	 *   {@link Tasks#defineIncrementalTask}).
	 * @param {FileSystem} fileSystem The file system that contains `incrementalDir`.
	 * @returns {Tasks} The instance.
	 */
	static create({
		incrementalDir,
		fileSystem,
	}) {
		ensure.signature(arguments, [{
			incrementalDir: String,
			fileSystem: FileSystem,
		}]);

		return new Tasks(incrementalDir, Clock.create(), fileSystem);
	}

	/**
	 * Factory method. Creates a Nulled instance that doesn't write to the file system.
	 * @param {string} [incrementalDir="/nulled_incremental_dir"] Path to a directory to use for incremental tasks (see {@link Tasks#defineIncrementalTask}).
	 * @param {Clock} [clock] System clock. Defaults to a Nulled instance.
	 * @param {FileSystem} [fileSystem] File system. Defaults to a Nulled instance.
	 * @returns {Tasks} The instance.
	 */
	static createNull({
		incrementalDir = "/nulled_incremental_dir",
		clock = Clock.createNull(),
		fileSystem = FileSystem.createNull(),
	} = {}) {
		ensure.signature(arguments, [[ undefined, {
			incrementalDir: [ undefined, String ],
			clock: [ undefined, Clock ],
			fileSystem: [ undefined, FileSystem ],
		}]]);

		return new Tasks(incrementalDir, clock, fileSystem);
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(incrementalDir, clock, fileSystem) {
		super();
		this._taskFns = {};
		this._descriptions = {};
		this._incrementalDir = incrementalDir;
		this._clock = clock;
		this._fileSystem = fileSystem;
	}

	/**
	 * Track when tasks start and end. Each action is tracked with its task, action, and timestamp.
	 * @returns {OutputTracker} The tracker.
	 * @see Tasks.ACTION
	 */
	track() {
		ensure.signature(arguments, []);

		return new OutputTracker(this, TASK_EVENT);
	}

	/**
	 * Add a task.
	 * @param {string} name The name of the task.
	 * @param {() => void} fn The function to run when the task executes.
	 * @throws Error Throws an error if the task name has already been used.
	 */
	defineTask(name, fn) {
		ensure.signature(arguments, [ String, Function ]);

		if (this._taskFns[name] === undefined) this._taskFns[name] = fn;
		else throw new Error(`Task already defined: ${name}`);
	}

	/**
	 * Add a special task that only runs when `sourceFiles` have changed. When the task finishes without an error, it
	 * writes a special task file to the `incrementalDir` (see {@link Tasks.create}. Whenever the task is supposed to
	 * run, it checks for the existance of that task file, and skips the task if it's newer than all the `sourceFiles`.
	 * @param {string} name The name of the task.
	 * @param {string[]} sourceFiles The files to compare to the task file.
	 * @param {() => void} fn The function to run when the task executes.
	 * @throws Error Throws an error if the task name has already been used.
	 */
	defineIncrementalTask(name, sourceFiles, fn) {
		ensure.signature(arguments, [ String, Array, Function ]);

		this.defineTask(name, async () => {
			const taskFile = `${this._incrementalDir}/${name}.task`;
			if (await this._fileSystem.isFileNewerThanAllAsync(taskFile, sourceFiles)) return;

			await fn();
			await this._fileSystem.writeTextFileAsync(taskFile, "ok");
		});
	}

	/**
	 * Add natural-language descriptions to the tasks. You're not required to give every task a description, but every
	 * task you describe must have already been defined.
	 * @param {Object.<name: string, description: string>} namesAndDescriptions An object containing the descriptions,
	 *   where the keys are the task names and the values are the task descriptions.
	 * @throws {Error} Throws error if any of the task names don't exist.
	 */
	setDescriptions(namesAndDescriptions) {
		ensure.signature(arguments, [ Object ]);

		Object.entries(namesAndDescriptions).forEach(([ key, value ]) => {
			ensure.that(
				this._taskFns[key] !== undefined,
				`Attempted to set description for '${key}', but that task hasn't been defined`,
			);
			ensure.that(
				this._descriptions[key] === undefined,
				`Attempted to set description for '${key}', but that task already has a description`,
			);

			this._descriptions[key] = value;
		});
	}

	/**
	 * Provides a list of all the tasks that have been added, along with their descriptions, if any. (Tasks without
	 * descriptions default to an empty string.)
	 * @returns {{name: string, description: string}[]} Each task in the order it was added.
	 */
	listTasks() {
		return Object.keys(this._taskFns).map(name => {
			const description = this._descriptions[name] ?? "";
			return { name, description };
		});
	}

	/**
	 * Checks if a task has been defined.
	 * @param {string} name The name of the task to check.
	 * @returns {boolean} True if the task has been defined.
	 */
	hasTask(name) {
		return this._taskFns[name] !== undefined;
	}

	/**
	 * Runs the requested tasks. Each task is run one at a time in the order provided.
	 * @param {string[]} tasksToRun The names of the tasks to run.
	 * @returns {Promise<void>}
	 * @throws Error Throws an error, without running any tasks, if any of the task names haven't been defined.
	 */
	async runTasksAsync(tasksToRun) {
		ensure.signature(arguments, [ Array ]);

		const unknownTasks = determineUnknownTasks(this._taskFns, tasksToRun);
		if (unknownTasks !== "") {
			throw new Error(`Unrecognized task(s): ${unknownTasks}`);
		}

		for (const task of tasksToRun) {
			try {
				this.emit(TASK_EVENT, { task, action: ACTION.START, timestamp: this._clock.now() });
				await this._taskFns[task]();
				this.emit(TASK_EVENT, { task, action: ACTION.END, timestamp: this._clock.now() });
			}
			catch (err) {
				if (err.failedTask === undefined) err.failedTask = task;
				throw err;
			}
		}
	}

}

function determineUnknownTasks(taskFns, tasksToRun) {
	return tasksToRun.filter((task) => taskFns[task] === undefined).join(", ");
}
