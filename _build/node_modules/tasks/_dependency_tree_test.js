// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."
"use strict";

const { suite, assert } = require("tests");
const ensure = require("util/ensure");
const DependencyTree = require("./dependency_tree");
const FileSystem = require("infrastructure/file_system");

module.exports = suite(({ describe }) => {

	describe("dependency analysis", ({ it }) => {

		it("recursively finds all dependencies for a file", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/child1.js");\n' +
					'require' + '("/child2.js");\n'
				},
				"/child1.js": { content:
					'require' + '("/grandchild1a.js");\n' +
					'require' + '("/grandchild1b.js");\n'
				},
				"/child2.js": {},
				"/grandchild1a.js": {},
				"/grandchild1b.js": { content:
					'require' + '("/greatgrandchild.js");\n'
				},
				"/greatgrandchild.js": {},
			});

			const { tree } = create({ fileSystem });

			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [
					"/root.js", "/child1.js", "/child2.js", "/grandchild1a.js", "/grandchild1b.js", "/greatgrandchild.js"
				],
				errors: [],
			});
		});

		it("optionally executes a notify function for every file that's read (but not cached files)", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/child1.js");\n' +
					'require' + '("/child2.js");\n'
				},
				"/child1.js": { content:
					'require' + '("/child2.js");\n'
				},
				"/child2.js": {},
			});

			const progress = [];
			function notifyFn(filename) {
				progress.push(filename);
			}

			const { tree } = create({ fileSystem });
			await tree.dependenciesForAsync("/root.js", notifyFn);

			assert.deepEqual(progress, [ "/root.js", "/child1.js", "/child2.js" ]);
		});

		it("uses Node's module resolution algorithm", async () => {
			const fileSystem = FileSystem.createNull({
				"/subdir/root.js": { content:
					'require' + '("./child");\n'  // note lack of extension
				},
				"/subdir/child.js": {}
			});

			const { tree } = create({ fileSystem });

			assert.deepEqual(await tree.dependenciesForAsync("/subdir/root.js"), {
				dependencies: [ "/subdir/root.js", "/subdir/child.js" ],
				errors: [],
			});
		});

		it("ignores Node dependencies", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("./child1.js");\n' +
					'require' + '("node:util");\n'
				},
				"/child1.js": {},
			});

			const { tree } = create({ fileSystem });

			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [ "/root.js", "/child1.js" ],
				errors: [],
			});
		});

		it("ignores dependencies that are in list of excluded globs", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("./child1.js");\n' +
					'require' + '("./child2_excluded.js");\n' +
					'require' + '("./excluded/child3.js");\n' +
					'require' + '("./excluded/child4.js");\n'
				},
				"/child1.js": {},
				"/child2_excluded.js": {},
				"/excluded/child3.js": {},
				"/excluded/child4.js": {},
			});

			const { tree } = create({
				fileSystem,
				globsToIgnore: [ "/child2_excluded.js", "/excluded/**" ],
			});

			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [ "/root.js", "/child1.js" ],
				errors: [],
			});
		});

		it("handles self-referential cycles", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/sibling.js");\n'
				},
				"/sibling.js": { content:
					'require' + '("/root.js");\n'
				},
			});

			const { tree } = create({ fileSystem });
			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [ "/root.js", "/sibling.js" ],
				errors: [],
			});
		});

	});


	describe("errors", ({ it }) => {

		it("returns error when child dependency can't be found", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/no_such_child.js");\n'
				},
			});

			const { tree } = create({ fileSystem });
			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [],
				errors: [{
					error: DependencyTree.ERRORS.DEPENDENCY_NOT_FOUND,
					file: "/root.js",
					dependency: "/no_such_child.js",
					line: 1,
					source: 'require' + '("/no_such_child.js");',
				}],
			});
		});

		it("returns multiple errors if multiple problems exist", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/no_such_child.js");\n' +
					'require' + '("/no_such_child2.js");\n' +
					'require' + '("/child.js");\n'
				},
				"/child.js": { content:
					'require' + '("/no_such_child3.js");\n'
				},
			});

			const { tree } = create({ fileSystem });
			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [],
				errors: [{
					error: DependencyTree.ERRORS.DEPENDENCY_NOT_FOUND,
					file: "/root.js",
					dependency: "/no_such_child.js",
					line: 1,
					source: 'require' + '("/no_such_child.js");',
				}, {
					error: DependencyTree.ERRORS.DEPENDENCY_NOT_FOUND,
					file: "/root.js",
					dependency: "/no_such_child2.js",
					line: 2,
					source: 'require' + '("/no_such_child2.js");',
				}, {
					error: DependencyTree.ERRORS.DEPENDENCY_NOT_FOUND,
					file: "/child.js",
					dependency: "/no_such_child3.js",
					line: 1,
					source: 'require' + '("/no_such_child3.js");',
				}],
			});
		});

		it("doesn't return dependencies if there were any errors", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/child.js");\n' +
					'require' + '("/no_such_child.js");\n'
				},
				"/child.js": {},
			});

			const { tree } = create({ fileSystem });
			assert.deepEqual((await tree.dependenciesForAsync("/root.js")).dependencies, []);
		});

		it("returns error when root file can't be found", async () => {
			const fileSystem = FileSystem.createNull();

			const { tree } = create({ fileSystem });
			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [],
				errors: [{
					error: DependencyTree.ERRORS.ROOT_NOT_FOUND,
					file: "/root.js",
				}],
			});
		});

	});


	describe("up-to-date analysis", ({ it }) => {

		it("finds files whose dependencies have changed", async () => {
			const fileSystem = FileSystem.createNull({
				"/comps/root1.js.ext": { modified: 100 },
				"/comps/root2.js.ext": { modified: 100 },
				"/comps/root3.js.ext": { modified: 100 },
				"/root1.js": { modified: 50, content:
					'require' + '("/child1.js");\n' +
					'require' + '("/child2.js");\n'
				},
				"/root2.js": { modified: 50, content:
					'require' + '("/child1.js");\n'
				},
				"/root3.js": { modified: 50, content:
					'require' + '("/child2.js");\n'
				},
				"/child1.js": { modified: 200 },
				"/child2.js": { modified: 50 },
			}, {
				rootDir: "/",
				timestampDir: "/comps",
			});

			const { tree } = create({ fileSystem });

			assert.deepEqual(
				await tree.findChangedFilesAsync([ "/root1.js", "/root2.js", "/root3.js" ], "ext"), {
					changed: [ "/root1.js", "/root2.js" ],
					errors: [],
				},
			);
		});

		it("considers a non-existent timestamp file to always be out of date", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": {},
			});

			const { tree } = create({ fileSystem });

			assert.deepEqual(await tree.findChangedFilesAsync([ "/root.js" ], "ext"), {
				changed: [ "/root.js" ],
				errors: [],
			});
		});

		it("collects errors from all analyzed files, without duplicates", async () => {
			const fileSystem = FileSystem.createNull({
				"/root1.js": { content:
					'require' + '("/child.js");\n' +
					'require' + '("/no_such_child1.js");\n'
				},
				"/root2.js": { content:
					'require' + '("/child.js");\n'
				},
				"/child.js": { content:
					'require' + '("/no_such_child2.js");\n'
				},
			});

			const { tree } = create({ fileSystem });

			assert.deepEqual(
				await tree.findChangedFilesAsync([ "/root1.js", "/root2.js" ], "ext"), {
					changed: [],
					errors: [{
						error: DependencyTree.ERRORS.DEPENDENCY_NOT_FOUND,
						file: "/root1.js",
						dependency: "/no_such_child1.js",
						line: 2,
						source: 'require' + '("/no_such_child1.js");',
					}, {
						error: DependencyTree.ERRORS.DEPENDENCY_NOT_FOUND,
						file: "/child.js",
						dependency: "/no_such_child2.js",
						line: 1,
						source: 'require' + '("/no_such_child2.js");',
					}],
				},
			);
		});

		it("executes notify function for every file that's read (but not cached files)", async () => {
			const fileSystem = FileSystem.createNull({
				"/root1.js": { content:
					'require' + '("/child.js");\n'
				},
				"/root2.js": { content:
					'require' + '("/child.js");\n'
				},
				"/child.js": {},
			});

			const progress = [];
			function notifyFn(filename) {
				progress.push(filename);
			}

			const { tree } = create({ fileSystem });
			await tree.findChangedFilesAsync([ "/root1.js", "/root2.js" ], "ext", notifyFn);

			assert.deepEqual(progress, [ "/root1.js", "/child.js", "/root2.js" ]);
		});

	});


	describe("caching", ({ it }) => {

		it("doesn't analyze files that have already been analyzed", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/child1.js");\n' +
					'require' + '("/child2.js");\n'
				},
				"/child1.js": { content:
					'require' + '("/child2.js");\n'
				},
				"/child2.js": {},
			});

			const fileSystemTracker = fileSystem.track();
			const { tree } = create({ fileSystem });

			await tree.dependenciesForAsync("/root.js");
			await tree.dependenciesForAsync("/root.js");

			assert.deepEqual(fileSystemTracker.data, [
				{ action: FileSystem.TRACK_ACTION.READ, filename: "/root.js" },
				{ action: FileSystem.TRACK_ACTION.MODULE_RESOLUTION, resolvedFilename: "/child1.js" },
				{ action: FileSystem.TRACK_ACTION.MODULE_RESOLUTION, resolvedFilename: "/child2.js" },
				{ action: FileSystem.TRACK_ACTION.READ, filename: "/child1.js" },
				{ action: FileSystem.TRACK_ACTION.READ, filename: "/child2.js" },
				{ action: FileSystem.TRACK_ACTION.MODULE_RESOLUTION, resolvedFilename: "/child2.js" },
			]);
		});

		it("doesn't analyze a file twice even if it's called twice in parallel", async () => {
			const fileSystem = FileSystem.createNull({
				"/root.js": { content:
					'require' + '("/child1.js");\n'
				},
				"/child1.js": {}
			});

			const reads = fileSystem.track();
			const { tree } = create({ fileSystem });

			await Promise.all([
				tree.dependenciesForAsync("/root.js"),
				tree.dependenciesForAsync("/root.js"),
			]);

			assert.deepEqual(reads.data, [
				{ action: FileSystem.TRACK_ACTION.READ, filename: "/root.js" },
				{ action: FileSystem.TRACK_ACTION.MODULE_RESOLUTION, resolvedFilename: "/child1.js" },
				{ action: FileSystem.TRACK_ACTION.READ, filename: "/child1.js" },
			]);
		});

		it("re-analyzes files that have been updated since they were last analyzed", async () => {
			const files = {
				"/root.js": {
					content: 'require' + '("/child1.js");\n',
				},
				"/child1.js": {
					content: 'require' + '("/child2a.js");\n',
					modified: 100,
				},
				"/child2a.js": {},
				"/child2b.js": {},
			};
			const fileSystem = FileSystem.createNull(files);

			const { tree } = create({ fileSystem });
			await tree.dependenciesForAsync("/root.js");

			files["/child1.js"].modified = 150;
			files["/child1.js"].content = 'require' + '("/child2b.js");\n';
			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [ "/root.js", "/child1.js", "/child2b.js" ],
				errors: [],
			});
		});

		it("re-analyzes files that have dependencies that don't exist", async () => {
			const files = {
				"/root.js": {
					content: 'require' + '("/child1.js");\n',
				},
				"/child1.js": {
					content: 'require' + '("/no_such_file.js");\n',
					modified: 100,
				},
				"/child2.js": {},
			};
			const fileSystem = FileSystem.createNull(files);

			const { tree } = create({ fileSystem });
			const { errors } = await tree.dependenciesForAsync("/root.js");
			assert.equal(errors[0].dependency, "/no_such_file.js");

			files["/child1.js"].modified = 150;
			files["/child1.js"].content = 'require' + '("/child2.js");\n';
			assert.deepEqual(await tree.dependenciesForAsync("/root.js"), {
				dependencies: [ "/root.js", "/child1.js", "/child2.js" ],
				errors: [],
			});
		});

	});

});


function create({
	fileSystem,
	globsToIgnore,
	reportHeadline = "irrelevant_report",
}) {
	ensure.signature(arguments, [{
		fileSystem: FileSystem,
		globsToIgnore: [ undefined, Array ],
		reportHeadline: [ undefined, String ],
	}]);

	const tree = new DependencyTree(fileSystem, globsToIgnore);
	return { tree };
}
