// Copyright Titanium I.T. LLC. License granted under terms of "The MIT License."
import { suite, assert } from "tests";
import Tasks from "tasks/tasks.js";
import Clock from "infrastructure/clock.js";
import FileSystem from "infrastructure/file_system.js";

const IRRELEVANT_SUCCESS_MESSAGE = "irrelevant_success_message";

export default suite(({ describe }) => {

	describe("defining and running tasks", ({ it }) => {

		it("runs tasks", async () => {
			const { tasks } = createTasks();

			let task1Ran = false;
			tasks.defineTask("task1", () => {
				task1Ran = true;
			});

			let task2Ran = false;
			tasks.defineTask("task2", () => {
				task2Ran = true;
			});

			let task3Ran = false;
			tasks.defineTask("task3", () => {
				task3Ran = true;
			});

			await tasks.runTasksAsync([ "task1", "task3" ]);
			assert.equal(task1Ran, true, "task 1 ran");
			assert.equal(task2Ran, false, "task 2 did not run");
			assert.equal(task3Ran, true, "task 3 ran");
		});

		it("runs async tasks", async () => {
			const { tasks } = createTasks();

			let taskRan = false;
			tasks.defineTask("my_task", async () => {
				await new Promise((resolve) => {
					setImmediate(() => {
						taskRan = true;
						resolve();
					});
				});
			});

			await tasks.runTasksAsync([ "my_task" ]);
			assert.equal(taskRan, true, "task ran");
		});

	});


	describe("events and tracking", ({ it }) => {

		it("tracks task events", async () => {
			const { tasks, clock } = createTasks();

			tasks.defineTask("parent_task", async () => {
				await tasks.runTasksAsync([ "child_task" ]);
				await clock.tickAsync(100);
			});
			tasks.defineTask("child_task", async () => {
				await clock.tickAsync(200);
			});

			const tracker = tasks.track();
			await tasks.runTasksAsync([ "parent_task" ]);

			assert.deepEqual(tracker.data, [
				{ task: "parent_task", action: "start", timestamp: 0 },
				{ task: "child_task", action: "start", timestamp: 0 },
				{ task: "child_task", action: "end", timestamp: 200 },
				{ task: "parent_task", action: "end", timestamp: 300 },
			]);
		});

		it("emits task events", async () => {
			const { tasks, clock } = createTasks();

			tasks.defineTask("parent_task", async () => {
				await tasks.runTasksAsync([ "child_task" ]);
				await clock.tickAsync(100);
			});
			tasks.defineTask("child_task", async () => {
				await clock.tickAsync(200);
			});

			const eventData = [];
			tasks.on(Tasks.TASK_EVENT, event => eventData.push(event));
			await tasks.runTasksAsync([ "parent_task" ]);

			assert.deepEqual(eventData, [
				{ task: "parent_task", action: "start", timestamp: 0 },
				{ task: "child_task", action: "start", timestamp: 0 },
				{ task: "child_task", action: "end", timestamp: 200 },
				{ task: "parent_task", action: "end", timestamp: 300 },
			]);
		});

	});


	describe("incremental tasks", ({ it }) => {

		it("runs if it's never been run before, and writes a task file", async () => {
			const { tasks, fileWrites } = createTasks({ incrementalDir: "/incremental_dir" });

			let taskRan = false;
			tasks.defineIncrementalTask("my_task", [ "/source_file" ], () => {
				taskRan = true;
			});

			await tasks.runTasksAsync([ "my_task" ]);

			assert.equal(taskRan, true, "should have ran task");
			assert.deepEqual(fileWrites, [
				{ action: FileSystem.TRACK_ACTION.WRITE, filename: "/incremental_dir/my_task.task", content: "ok" },
			], "should have written task file");
		});

		it("doesn't run or write file if the file exists and is newer than the source files", async () => {
			const fileSystem = FileSystem.createNull({
				"/incremental_dir/my_task.task": { modified: 100 },
				"/source_file1": { modified: 50 },
				"/source_file2": { modified: 50 },
			});
			const { tasks, fileWrites } = createTasks({ fileSystem, incrementalDir: "/incremental_dir" });

			let taskRan = false;
			tasks.defineIncrementalTask("my_task", [ "/source_file1", "/source_file2" ], () => {
				taskRan = true;
			});

			await tasks.runTasksAsync([ "my_task" ]);

			assert.equal(taskRan, false, "should not have ran task");
			assert.deepEqual(fileWrites, [], "should not have written task file");
		});

		it("does run and write file if the file exists but isn't newer than the source files", async () => {
			const fileSystem = FileSystem.createNull({
				"/incremental_dir/my_task.task": { modified: 100 },
				"/source_file1": { modified: 100 },
				"/source_file2": { modified: 50 },
			});
			const { tasks, fileWrites } = createTasks({ fileSystem, incrementalDir: "/incremental_dir" });

			let taskRan = false;
			tasks.defineIncrementalTask("my_task", [ "/source_file1", "/source_file2" ], () => {
				taskRan = true;
			});

			await tasks.runTasksAsync([ "my_task" ]);

			assert.equal(taskRan, true, "should have ran task");
			assert.deepEqual(fileWrites, [
				{ action: FileSystem.TRACK_ACTION.WRITE, filename: "/incremental_dir/my_task.task", content: "ok" },
			], "should have written task file");
		});

	});


	describe("exception handling", ({ it }) => {

		it("throws exception when task has already been defined", async () => {
			const { tasks } = createTasks();

			tasks.defineTask("my_task", () => {});
			await assert.exceptionAsync(
				() => tasks.defineTask("my_task", () => {}),
				"Task already defined: my_task",
			);
		});

		it("throws exception when requested tasks don't exist", async () => {
			const { tasks } = createTasks();

			let taskRan = false;
			tasks.defineTask("my_task", () => {
				taskRan = true;
			});

			await assert.exceptionAsync(
				() => tasks.runTasksAsync([ "my_task", "no_such_task", "another_no_such_task" ]),
				"Unrecognized task(s): no_such_task, another_no_such_task",
			);
			assert.equal(taskRan, false, "shouldn't run any tasks");
		});

		it("propagates exceptions and adds name of failed task", async () => {
			const { tasks } = createTasks();

			tasks.defineTask("my_task", () => {
				throw new Error("my task failure");
			});

			try {
				await tasks.runTasksAsync([ "my_task" ]);
				assert.fail("expected exception");
			}
			catch(err) {
				assert.equal(err.message, "my task failure", "exception's message");
				assert.equal(err.failedTask, "my_task", "exception's failed task");
			}
		});

		it("doesn't overwrite name of failed task when tasks are nested", async () => {
			const { tasks } = createTasks();

			tasks.defineTask("parent_task", async () => {
				await tasks.runTasksAsync([ "child_task" ]);
			});
			tasks.defineTask("child_task", () => {
				throw new Error("child task failure");
			});

			try {
				await tasks.runTasksAsync([ "parent_task" ]);
				assert.fail("expected exception");
			}
			catch(err) {
				assert.equal(err.message, "child task failure", "exception's message");
				assert.equal(err.failedTask, "child_task", "exception's failed task");
			}
		});

	});


	describe("task lists and descriptions", ({ it }) => {

		it("says if a task exists", () => {
			const { tasks } = createTasks();

			tasks.defineTask("my_task", () => {});

			assert.equal(tasks.hasTask("my_task"), true, "should have task");
			assert.equal(tasks.hasTask("no_such_task"), false, "should not have task");
		});

		it("provides a list of defined tasks", () => {
			const { tasks } = createTasks();

			tasks.defineTask("task1", () => {});
			tasks.defineTask("task2", () => {});
			tasks.defineTask("task3", () => {});

			assert.deepEqual(tasks.listTasks(), [
				{ name: "task1", description: "" },
				{ name: "task2", description: "" },
				{ name: "task3", description: "" },
			]);
		});

		it("allows descriptions to be added to tasks", () => {
			const { tasks } = createTasks();

			tasks.defineTask("task1", () => {});
			tasks.defineTask("task2", () => {});
			tasks.defineTask("task3", () => {});

			tasks.setDescriptions({
				task1: "description 1",
				task3: "description 3",
			});

			assert.deepEqual(tasks.listTasks(), [
				{ name: "task1", description: "description 1" },
				{ name: "task2", description: "" },
				{ name: "task3", description: "description 3" },
			]);
		});

		it("can add descriptions in stages", () => {
			const { tasks } = createTasks();

			tasks.defineTask("task1", () => {});
			tasks.defineTask("task2", () => {});
			tasks.defineTask("task3", () => {});

			tasks.setDescriptions({ task1: "description 1" });
			tasks.setDescriptions({ task3: "description 3" });

			assert.deepEqual(tasks.listTasks(), [
				{ name: "task1", description: "description 1" },
				{ name: "task2", description: "" },
				{ name: "task3", description: "description 3" },
			]);

		});

		it("throws an exception when setting the description for a task that doesn't exist", () => {
			const { tasks } = createTasks();

			assert.exception(
				() => tasks.setDescriptions({ noSuchTask: "irrelevant description" }),
				"Attempted to set description for 'noSuchTask', but that task hasn't been defined",
			);
		});

		it("throws an exception when setting the description for a task that already has a description", () => {
			const { tasks } = createTasks();
			tasks.defineTask("my_task", () => {});
			tasks.setDescriptions({ my_task: "my description" });

			assert.exception(
				() => tasks.setDescriptions({ my_task: "another description" }),
				"Attempted to set description for 'my_task', but that task already has a description",
			);
		});

	});


});


function createTasks({
	incrementalDir = "/irrelevant/incremental/dir",
	clock = Clock.createNull(),
	fileSystem = FileSystem.createNull(),
} = {}) {
	const writeTracker = fileSystem.track();
	const tasks = new Tasks(incrementalDir, clock, fileSystem);

	return {
		tasks,
		fileWrites: writeTracker.data,
		clock,
	};
}
